动态代理（理解）：基于反射机制。
掌握的程度
	1.什么是动态代理？
		使用JDK的反射机制，创建对象的能力，创建的是代理类的对象，而不用你创建类文件。不用写java文件。
		动态：
			在程序的执行时，调用jdk提供的方法才能创建代理类的对象。

	2.知道动态代理能做什么？

	后面会讲 mybatis，spring

---------------------------------------------

一、代理

	1.代理简介：
		例如：中介，换ip，商家等等都是代理
		比如一家美国的大学，可以对全世界招生。留学中介（代理）

		留学中介（代理）：帮助这家美国的学校招生，中介是这家学校的代理吗，中介是代替学校完成招生功能。
			代理特点：
				- 中介和代理他们要做的事情是一致的：招生。
				- 中介是学校的代理，学校是目标。
				流程：家长--找-->中介（学校的介绍，办入学手续）--->美国的学校
				- 中介是代理，不能白干活，需要收取费用。

			为什么要找中介呢？
				- 中介是专业的，方便
				- 家长现在不能自己去找学校，家长没有能力访问学校，或者美国学校不接受个人来访。

			买东西都是商家卖，商家就是某个商品的代理，你个人买东西，肯定不会让你接触到厂家。

		在开发中也会有这样的情况，你有a类，本来是调用c类的方法，完成某个功能。但是c不让a调用。

		a ---- 不能调用c 的方法
		在a 和 c 直接创建一个b代理， c让b访问
		a --- 访问b --- 访问c

		实际的例子：登陆 ， 注册有验证码，验证码是手机短信。

		中国移动，联通能发短信。

		中国移动，联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能

		张三项目发送短信---子公司，或者关联公司---- 中国移动，联通

	2.代理作用：
		- 功能增强：在你原有的功能上增加了额外的功能。新增加的功能，叫做功能增强
		- 控制访问：代理类不让你访问目标，例如商家不让用户访问厂家。

	3.实现代理的方式：
		- 静态代理：	
			* 代理类自己手工实现的，自己创建一个java类，表示代理类。同时你索要代理的目标类是确定的。
			* 同时你索要代理的目标类是确定的。

			特点：
				1）实现简单
				2）容易理解
			缺点：（当你的项目中，目标类和代理类很多的时候，有以下缺点）
				1）当目标类增加了，代理类可能也需要成倍的增加。代理类数量过多
				2）当接口中功能增加了，或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多

			例：模拟一个用户购买u盘的行为。
				用户：客户端类
				商家：代理，代理某个品牌的u盘。
				厂家：目标类。

				三者的关系： 用户（客户端） --- 商家（代理） --- 厂家（目标）
				商家和厂家都是卖u盘的，他们完成的功能是一致的，都是卖u盘

			实现步骤：
				1）创建一个接口，定义卖u盘的方法，表示你的厂家和商家做的事情。
				2）创建厂家类，实现1步骤的接口
				3）创建商家，就是代理，也需要实现1步骤中的接口。
				4）创建客户端类，调用商家的方法买一个u盘

			代理类完成的功能：
				1）目标类中方法的调用
				2）功能增强

		- 动态代理：
			在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点。
			动态代理中目标类即使很多
			1）代理类数量可以很少
			2）当你修改了接口中的方法时，不会影响代理类。

			* 定义：在程序的执行过程中，使用jdk的反射机制，创建代理类对象，并动态的指定要代理的目标类。
				（换句话说）：动态代理是一种创建java对象的能力，让你不用创建TaoBao类，技能创建代理类对象。

				在java中，要想创建对象：
					1）创建类文件，java文件编译为class
					2）使用构造方法，创建类的对象。

			* 动态代理的实现：
				1）jdk动态代理（理解）：使用java反射包中的类和接口实现动态代理的功能。
					反射包 java.lang.reflect , 里面有三个类：InvocationHandler , Method , Proxy

				2）cglib动态代理（了解）：cglib是一个第三方的工具库，创建代理对象。
					cglib的原理是继承，cglib通过继承目标类，创建他的子类，在子类中重写父类中同名的方法，实现功能的修改。
					因为cglib是继承，重写方法，所以要求目标类不能是final的，方法也不能是final。
					cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用。比如：mybatis，spring框架中都有使用。
					　　

二、jdk动态代理
	1.反射，Method类，表示方法。类中的方法。通过Method可以执行某个方法。

	2.jdk动态代理的实现
		反射包 java.lang.reflect , 里面有三个类：InvocationHandler , Method, Proxy.

			* InvocationHandler 接口（调用处理器）： 就一个方法invoke()
				invoke() ：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()中

				代理类完成的功能：
					- 调用目标方法，执行目标方法的功能
					- 功能增强，在目标方法调用时，增加功能。

				方法原型：
					public Object invoke(Object proxy, Method method, Object[] args)
						参数：
							Object proxy：jdk创建的代理对象，无需赋值。
							Method method：目标类中的方法，jdk提供method对象的
							Object[] args：目标类中方法的参数，jdk提供的

				InvocationHandler接口：表示你的代理要干什么。
				如何使用？
					- 创建类实现接口InvocationHandler
					- 重写invoke()方法，把原来静态代理中代理类要完成的功能，写在这里面

			* Method类：表示方法的，确切的说就是目标类中的方法。
				作用：通过Method可以执行某个目标类的方法，Method.invoke();
					method.invoke(目标对象,方法的参数)
					Object ret = method.invoke(service2,"里斯");

				说明：method.invoke()就是用来执行目标方法的，等同于静态代理中的
					向厂家发送订单，告诉厂家，我买了u盘，厂家发货
	        		float price = factory.sell(amount); // 厂家的价格
					
	        * Proxy类：核心的对象，创建代理对象。之前创建对象都是new 类的构造方法()
	        	现在我们是使用Proxy类的方法，代替new的使用。

	        	方法：静态方法 newProxyInstance()
	        	作用：创建代理对象，等同于静态代理中——new TaoBao();

	        	方法原型：
	        		public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h);
                    	参数：
                    		- ClassLoader loader ：类加载器，负责向内存加载对象的。使用反射获取对象的classLoader
                    			类a，a.getClass().getClassLoader(); ，目标对象的类加载器
                    		- Class<?>[] interfaces ：接口，目标对象实现的接口，也是反射获取的。
                    		- InvocationHandler h ：我们自己写的，代理类要完成的功能
                    	返回值：就是代理对象
