/*
		关于java中的整数型
			byte
			short
			int
			long
*/
public class DataTypeTest05
{
	public static void main(String[] args)
	{
		//100L 是long类型字面值
		//x是long类型变量
		//不存在类型转换。直接赋值
		long x =100L;

		//x变量是long类型，8个字节
		//y类型是int类型，4个字节

		//int y = x;// 这样会编译错误，因为大容量不能直接赋值小容量（报错：不兼容的类型: 从long转换到int可能会有损失）

		//大容量转换成小容量，需要进行强制类型转换
		//强制类型转换需要加"强制类型转换符"
		//加上强制类型转换符之后编译通过了，但是运行阶段可能损失精度。
		//所以强制类型转换谨慎使用，因为精度之后可能损失很严重

		//强转原理：
		  //原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100 （long类型、八个字节）
		  //强转之后的数据：00000000 00000000 00000000 01100100
		  // 将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】

		int y = (int)x;
		System.out.println(y);

		long k = 2147483648L;
		int e =(int)k;
		System.out.println(e);

		byte b = 50;//依据目前所学内容：(这里的50 默认是int类型的字面值，而'b'字符是byte类型的变量)
		//看的出这句话（byte b = 50;）是将大容量的int转换成了小容量的byte
		//大同量转换成小容量是需要添加强制转换类型的转换符的，以下程序没有添加强制转换符，所以按道理来说编译报错

		//但是sum公司对byte有特殊语法机制，当字面值没有超过byte类型取值范围，则可以直接赋值给byte类型的变量，而无需类型的转换
		//--->#java语言中当一个整形字面值没有超出byte类型取值范围，该字面值可以直接赋值给byte类型的变量
		byte d = 120;//本应该强制转换
		byte c =127;//但是这里仍然能够通过由于#——>
		byte b1 =(byte)128;
						 //128超过了byte类型的字面值，所以无法赋值，需要强制转换 byte k = （byte）128；
						//原始数据：00000000 00000000 00000000 10000000
						//强转之后：10000000【这是储存在计算机内部的，这是一个补码，他的原码
		System.out.println(b1);
		/*
              计算机二进制有三种表示形式：
                原码
                反码
                反码
              计算机在任何情况下底层表示和储存数据的时候采用了补码形式。
              正数的补码：和原码相同
              负数的补码：负数的绝对值对应的二进制码所有的二进制位取反，再加1

              补码：10000000
              原码计算过程：
                  *10000000-1 ————>01111111  
                  *10000000   ----->-128
                  *-128
		*/
      byte m = (byte)198; //	二进制原码为：00000000 00000000 0000000 11000110  //强制类型转换之后为 11000110
         //11000110现在在计算机当中存储，他是一个补码，将补码转换成原码就是该数字
         //11000110 -1 =11000101
         //10111010【2 + 8 + 16 + 32】最后的结果就是-58
         System.out.println(m);

      short n =32767;
      //short s1=32768;(若是执行也会报错)，若是字节类型没有超过short的取值范围可以直接自动转换，但是超过的话就无法自动必须强制转换。
      char cc =65535
      //65535 是int类型，4个字节
      //cc 是char类型，2个字节
      //按照以前所学知识点来说，char cc = 65535无法进行编译
     
//当一个整数字面值没有超过byte,short,char的取值范围，这个字面值可以直接赋值给byte，short，char类型的变量。
      //这种机制SUN允许了，目的是为了方便程序员的编程。


	}
}