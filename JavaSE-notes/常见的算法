1、常见的算法
	排序算法：
		冒泡排序算法
		选择排序算法
		堆排序（面试不咋用）

	查找算法：	
		二分法查找

	以上算法在以后的java实际开发中我们不需要使用的。
	因为java已经封装好了，直接调用就行。
	只不过以后面试的时候，可能会有机会碰上。

2、算法实际上在java中不需要精通，因为java中已经封装好了，
要排序就调用方法就行。例如：java中提供了一个数组工具类：	
	java.util.Arrays
		Arrays是一个工具类。
		其中有一个sort()方法，可以排序。静态方法，直接使用类名调用就行。

3、冒泡排序（自己看代码）
	//这个是我自己想出来的
	for(int x=1;x<i.length;x++){
            for(int a=0;a<i.length-x;a++){
                if(i[a]>i[a+1]){
                    int j= i[a];
                    i[a]=i[a+1];
                    i[a+1]=j;
                }
            }
    }

    //这个是老师的标准方法
    for(int i=arr.length-1;i>0;i--){
            for(int j=0;j<i;j++){
                if(arr[j]>arr[j+1]){
                    int x = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1]=x;
                }
            }
    }

4、选择排序：
	选择排序比冒泡排序的效率高。
	高在交换位置的次数上。
	选择排序的交换位置是有意义的。

	循环一次，然后找出参加比较的这堆数据中最小的，拿着这个最小的值和
	最前面的数据交换位置。
代码：
		for(int i =0;i<arr.length-1;i++) {
            // i的值是0，1，2，3
            // i正好是"参加比较的这堆数据中"最左边那个元素的下标。
            // i是一个参与比较的这堆数据的起点下标。
            // 假设i起点下标上的元素是最小值
            int min=i;
            for(int j=i+1;j<arr.length;j++){
               count++;
               if(arr[j]<arr[min]){
                   min=j;
               }
               // 当i和min相等时，表示最初猜测是对的。
               // 当i和min不想等时，表示最初的猜测是错的。有比这个更小的元素
               // 这时候就需要将最小的元素和第一个这个参与比较里的第一个元素进行调换位置。
               if(min!=i){
                   int temp=arr[min];
                   arr[min]=arr[i];
                   arr[i]=temp;
                   count2++;
               }
            }
        }


5、二分法查找：(折半查找）

	第一、二分法查找建立在排序的基础之上。
	第二：二分法查找效率要高于“一个挨着一个”的这种查找方式。	
	第三：二分法查找原理？
		10(0下标) 23 56 89 100 111 222 235 500 600(下标9)

		目标：找出600的下标
			(0+9)/2 ---> 4 （中间元素的下标）

		arr[4]这个元素就是中间元素：arr[4]是 100
		100 < 600
		说明被查找的元素在100的右边。
		此时开始下标变成：4 + 1

			（5 + 9）/2 -- > 7(中间元素的下标)
			arr[7] 对应的是：235
			235 < 600
			说明被查找的元素在235的右边。

		开始下标又进行了转变：7 + 1	
			（8 + 9）/2 --> 8
			arr[8] -- > 500
			500 < 600
			开始元素的下标又发生了变化： 8 + 1
			（9 + 9）/2 --->9
			arr[9]是600，正好和600相等，此时找到了。
代码：
    public static int binarySearch(int arr[] ,int dest){
        // 开始下标
        int begin = 0;

        // 结束下标
        int end = arr.length-1;

        // 开始元素的下标只要在结束元素下标的左边，就有机会一直循环。
        while(begin <= end) {
            // 中间元素下标
            int mid = (end + begin) / 2;

            if (arr[mid] == dest) {
                return mid;
            } else if (arr[mid] < dest) {
                // 目标在"中间"的右边
                // 开始元素下标需要发生变化(开始元素下标需要重新赋值)
                begin = mid + 1;// 一直增
            } else {
                // arr[mid] > dest
                // 目标在中间的左边
                end = mid - 1;// 一直减
            }
        }
        return -1;
    }

6、介绍一下java.util.Arrays工具类。
	所有的方法都是静态的，直接用类名调用
	主要使用的是两个方法：
		二分法查找，排序
	以后要看文档，不要死记硬背。
		



